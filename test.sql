CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX N_g___0 ON N_g (_0)

CREATE INDEX N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX E_g___0 ON E_g (_0)

CREATE INDEX E_g___1 ON E_g (_1)

CREATE INDEX E_g___2 ON E_g (_2)

CREATE INDEX E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R2 CROSS JOIN N_g AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX N_g___0 ON N_g (_0)

CREATE INDEX N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX E_g___0 ON E_g (_0)

CREATE INDEX E_g___1 ON E_g (_1)

CREATE INDEX E_g___2 ON E_g (_2)

CREATE INDEX E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R2 CROSS JOIN N_g AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX N_g___0 ON N_g (_0)

CREATE INDEX N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX E_g___0 ON E_g (_0)

CREATE INDEX E_g___1 ON E_g (_1)

CREATE INDEX E_g___2 ON E_g (_2)

CREATE INDEX E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX N_g___0 ON N_g (_0)

CREATE INDEX N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX E_g___0 ON E_g (_0)

CREATE INDEX E_g___1 ON E_g (_1)

CREATE INDEX E_g___2 ON E_g (_2)

CREATE INDEX E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R2 CROSS JOIN N_g AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX N_g___0 ON N_g (_0)

CREATE INDEX N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX E_g___0 ON E_g (_0)

CREATE INDEX E_g___1 ON E_g (_1)

CREATE INDEX E_g___2 ON E_g (_2)

CREATE INDEX E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX N_g___0 ON N_g (_0)

CREATE INDEX N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX E_g___0 ON E_g (_0)

CREATE INDEX E_g___1 ON E_g (_1)

CREATE INDEX E_g___2 ON E_g (_2)

CREATE INDEX E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX N_g___0 ON N_g (_0)

CREATE INDEX N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX E_g___0 ON E_g (_0)

CREATE INDEX E_g___1 ON E_g (_1)

CREATE INDEX E_g___2 ON E_g (_2)

CREATE INDEX E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX N_g___0 ON N_g (_0)

CREATE INDEX N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX E_g___0 ON E_g (_0)

CREATE INDEX E_g___1 ON E_g (_1)

CREATE INDEX E_g___2 ON E_g (_2)

CREATE INDEX E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX N_g___0 ON N_g (_0)

CREATE INDEX N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX E_g___0 ON E_g (_0)

CREATE INDEX E_g___1 ON E_g (_1)

CREATE INDEX E_g___2 ON E_g (_2)

CREATE INDEX E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX N_g___0 ON N_g (_0)

CREATE INDEX N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX E_g___0 ON E_g (_0)

CREATE INDEX E_g___1 ON E_g (_1)

CREATE INDEX E_g___2 ON E_g (_2)

CREATE INDEX E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX N_g___0 ON N_g (_0)

CREATE INDEX N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX E_g___0 ON E_g (_0)

CREATE INDEX E_g___1 ON E_g (_1)

CREATE INDEX E_g___2 ON E_g (_2)

CREATE INDEX E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX N_g___0 ON N_g (_0)

CREATE INDEX N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX E_g___0 ON E_g (_0)

CREATE INDEX E_g___1 ON E_g (_1)

CREATE INDEX E_g___2 ON E_g (_2)

CREATE INDEX E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX N_g___0 ON N_g (_0)

CREATE INDEX N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX E_g___0 ON E_g (_0)

CREATE INDEX E_g___1 ON E_g (_1)

CREATE INDEX E_g___2 ON E_g (_2)

CREATE INDEX E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX N_g___0 ON N_g (_0)

CREATE INDEX N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX E_g___0 ON E_g (_0)

CREATE INDEX E_g___1 ON E_g (_1)

CREATE INDEX E_g___2 ON E_g (_2)

CREATE INDEX E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX N_g___0 ON N_g (_0)

CREATE INDEX N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX E_g___0 ON E_g (_0)

CREATE INDEX E_g___1 ON E_g (_1)

CREATE INDEX E_g___2 ON E_g (_2)

CREATE INDEX E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX N_g___0 ON N_g (_0)

CREATE INDEX N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX E_g___0 ON E_g (_0)

CREATE INDEX E_g___1 ON E_g (_1)

CREATE INDEX E_g___2 ON E_g (_2)

CREATE INDEX E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R2 CROSS JOIN N_g AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R2 CROSS JOIN N_g AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_FriendsView AS R0 CROSS JOIN N_FriendsView AS R2 CROSS JOIN N_FriendsView AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_FriendsView AS R0 CROSS JOIN N_FriendsView AS R2 CROSS JOIN N_FriendsView AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_FriendsView AS R0 CROSS JOIN N_FriendsView AS R2 CROSS JOIN N_FriendsView AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_FriendsView AS R0 CROSS JOIN N_FriendsView AS R2 CROSS JOIN N_FriendsView AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_FriendsView AS R0 CROSS JOIN N_FriendsView AS R2 CROSS JOIN N_FriendsView AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_FriendsView AS R0 CROSS JOIN N_FriendsView AS R2 CROSS JOIN N_FriendsView AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_FriendsView AS R0 CROSS JOIN N_FriendsView AS R2 CROSS JOIN N_FriendsView AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

DROP VIEW IF EXISTS DMAP_FriendsView CASCADE

CREATE VIEW DMAP_FriendsView AS ((SELECT DISTINCT R0._0 AS _0, R0._0 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS N_FriendsView CASCADE

CREATE VIEW N_FriendsView AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS E_FriendsView CASCADE

CREATE VIEW E_FriendsView AS ((SELECT DISTINCT R0._0 AS _0, R1._1 AS _1, R2._1 AS _2, R0._3 AS _3 FROM E_g AS R0 CROSS JOIN DMAP_FriendsView AS R1 CROSS JOIN DMAP_FriendsView AS R2 WHERE R0._2 = R2._0 AND R0._1 = R1._0));

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_FriendsView AS R0 CROSS JOIN N_FriendsView AS R2 CROSS JOIN N_FriendsView AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_FriendsView_0 CASCADE

CREATE VIEW MATCH_FriendsView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

DROP VIEW IF EXISTS DMAP_FriendsView CASCADE

CREATE VIEW DMAP_FriendsView AS ((SELECT DISTINCT R0._0 AS _0, R0._0 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS N_FriendsView CASCADE

CREATE VIEW N_FriendsView AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS E_FriendsView CASCADE

CREATE VIEW E_FriendsView AS ((SELECT DISTINCT R0._0 AS _0, R1._1 AS _1, R2._1 AS _2, R0._3 AS _3 FROM E_g AS R0 CROSS JOIN DMAP_FriendsView AS R1 CROSS JOIN DMAP_FriendsView AS R2 WHERE R0._2 = R2._0 AND R0._1 = R1._0));

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_FriendsView AS R0 CROSS JOIN N_FriendsView AS R2 CROSS JOIN N_FriendsView AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_V1_0 CASCADE

CREATE VIEW MATCH_V1_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

DROP VIEW IF EXISTS DMAP_V1 CASCADE

CREATE VIEW DMAP_V1 AS ((SELECT DISTINCT R0._0 AS _0, R0._0 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS N_V1 CASCADE

CREATE VIEW N_V1 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS E_V1 CASCADE

CREATE VIEW E_V1 AS ((SELECT DISTINCT R0._0 AS _0, R1._1 AS _1, R2._1 AS _2, R0._3 AS _3 FROM E_g AS R0 CROSS JOIN DMAP_V1 AS R1 CROSS JOIN DMAP_V1 AS R2 WHERE R0._2 = R2._0 AND R0._1 = R1._0));

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_V1 AS R0 CROSS JOIN N_V1 AS R2 CROSS JOIN N_V1 AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_V1_0 CASCADE

CREATE VIEW MATCH_V1_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

DROP VIEW IF EXISTS DMAP_V1 CASCADE

CREATE VIEW DMAP_V1 AS ((SELECT DISTINCT R0._0 AS _0, R0._0 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS N_V1 CASCADE

CREATE VIEW N_V1 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS E_V1 CASCADE

CREATE VIEW E_V1 AS ((SELECT DISTINCT R0._0 AS _0, R1._1 AS _1, R2._1 AS _2, R0._3 AS _3 FROM E_g AS R0 CROSS JOIN DMAP_V1 AS R1 CROSS JOIN DMAP_V1 AS R2 WHERE R0._2 = R2._0 AND R0._1 = R1._0));

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_V1 AS R0 CROSS JOIN N_V1 AS R2 CROSS JOIN N_V1 AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_V1_0 CASCADE

CREATE VIEW MATCH_V1_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

DROP VIEW IF EXISTS DMAP_V1 CASCADE

CREATE VIEW DMAP_V1 AS ((SELECT DISTINCT R0._0 AS _0, R0._0 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS N_V1 CASCADE

CREATE VIEW N_V1 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS E_V1 CASCADE

CREATE VIEW E_V1 AS ((SELECT DISTINCT R0._0 AS _0, R1._1 AS _1, R2._1 AS _2, R0._3 AS _3 FROM E_g AS R0 CROSS JOIN DMAP_V1 AS R1 CROSS JOIN DMAP_V1 AS R2 WHERE R0._2 = R2._0 AND R0._1 = R1._0));

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_V1 AS R0 CROSS JOIN N_V1 AS R2 CROSS JOIN N_V1 AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO N_g VALUES (3, 'Person');

INSERT INTO E_g VALUES (10, 1, 2, 'Knows');

INSERT INTO E_g VALUES (11, 2, 3, 'Knows');

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_V1_0 CASCADE

CREATE VIEW MATCH_V1_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

DROP VIEW IF EXISTS DMAP_V1 CASCADE

CREATE VIEW DMAP_V1 AS ((SELECT DISTINCT R0._0 AS _0, R0._0 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS N_V1 CASCADE

CREATE VIEW N_V1 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS E_V1 CASCADE

CREATE VIEW E_V1 AS ((SELECT DISTINCT R0._0 AS _0, R1._1 AS _1, R2._1 AS _2, R0._3 AS _3 FROM E_g AS R0 CROSS JOIN DMAP_V1 AS R1 CROSS JOIN DMAP_V1 AS R2 WHERE R0._2 = R2._0 AND R0._1 = R1._0));

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_V1 AS R0 CROSS JOIN N_V1 AS R2 CROSS JOIN N_V1 AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('Entity');

INSERT INTO N_schema VALUES ('Concept');

INSERT INTO E_schema VALUES ('Entity', 'Entity', 'RelatesTo');

INSERT INTO E_schema VALUES ('Entity', 'Concept', 'IsA');

INSERT INTO N_g VALUES (1, 'Entity');

INSERT INTO N_g VALUES (2, 'Entity');

INSERT INTO N_g VALUES (3, 'Concept');

INSERT INTO E_g VALUES (100, 1, 2, 'RelatesTo');

INSERT INTO E_g VALUES (101, 1, 3, 'IsA');

INSERT INTO NP_g VALUES (1, 'name', 'Alice');

INSERT INTO NP_g VALUES (2, 'name', 'Bob');

INSERT INTO NP_g VALUES (3, 'name', 'Person');

((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R2 CROSS JOIN N_g AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'RelatesTo' AND R2._1 = 'Entity' AND R4._1 = 'Entity'));

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_EntityRelations_0 CASCADE

CREATE VIEW MATCH_EntityRelations_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'RelatesTo' AND R1._1 = 'Entity' AND R2._1 = 'Entity'));

DROP VIEW IF EXISTS DMAP_EntityRelations CASCADE

CREATE VIEW DMAP_EntityRelations AS ((SELECT DISTINCT R0._0 AS _0, R0._0 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS N_EntityRelations CASCADE

CREATE VIEW N_EntityRelations AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS E_EntityRelations CASCADE

CREATE VIEW E_EntityRelations AS ((SELECT DISTINCT R0._0 AS _0, R1._1 AS _1, R2._1 AS _2, R0._3 AS _3 FROM E_g AS R0 CROSS JOIN DMAP_EntityRelations AS R1 CROSS JOIN DMAP_EntityRelations AS R2 WHERE R0._2 = R2._0 AND R0._1 = R1._0));

((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_EntityRelations AS R0 CROSS JOIN N_EntityRelations AS R2 CROSS JOIN N_EntityRelations AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'RelatesTo' AND R2._1 = 'Entity' AND R4._1 = 'Entity'));

INSERT INTO N_schema VALUES ('Entity');

INSERT INTO N_schema VALUES ('Concept');

INSERT INTO E_schema VALUES ('Entity', 'Entity', 'RelatesTo');

INSERT INTO E_schema VALUES ('Entity', 'Concept', 'IsA');

INSERT INTO N_g VALUES (1, 'Entity');

INSERT INTO N_g VALUES (2, 'Entity');

INSERT INTO N_g VALUES (3, 'Concept');

INSERT INTO E_g VALUES (100, 1, 2, 'RelatesTo');

INSERT INTO E_g VALUES (101, 1, 3, 'IsA');

INSERT INTO NP_g VALUES (1, 'name', 'Alice');

INSERT INTO NP_g VALUES (2, 'name', 'Bob');

INSERT INTO NP_g VALUES (3, 'name', 'Person');

((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R2 CROSS JOIN N_g AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'RelatesTo' AND R2._1 = 'Entity' AND R4._1 = 'Entity'));

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_EntityRelations_0 CASCADE

CREATE VIEW MATCH_EntityRelations_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'RelatesTo' AND R1._1 = 'Entity' AND R2._1 = 'Entity'));

DROP VIEW IF EXISTS DMAP_EntityRelations CASCADE

CREATE VIEW DMAP_EntityRelations AS ((SELECT DISTINCT R0._0 AS _0, R0._0 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS N_EntityRelations CASCADE

CREATE VIEW N_EntityRelations AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS E_EntityRelations CASCADE

CREATE VIEW E_EntityRelations AS ((SELECT DISTINCT R0._0 AS _0, R1._1 AS _1, R2._1 AS _2, R0._3 AS _3 FROM E_g AS R0 CROSS JOIN DMAP_EntityRelations AS R1 CROSS JOIN DMAP_EntityRelations AS R2 WHERE R0._2 = R2._0 AND R0._1 = R1._0));

((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_EntityRelations AS R0 CROSS JOIN N_EntityRelations AS R2 CROSS JOIN N_EntityRelations AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'RelatesTo' AND R2._1 = 'Entity' AND R4._1 = 'Entity'));

INSERT INTO N_schema VALUES ('Entity');

INSERT INTO N_schema VALUES ('Concept');

INSERT INTO E_schema VALUES ('Entity', 'Entity', 'RelatesTo');

INSERT INTO E_schema VALUES ('Entity', 'Concept', 'IsA');

INSERT INTO N_g VALUES (1, 'Entity');

INSERT INTO N_g VALUES (2, 'Entity');

INSERT INTO N_g VALUES (3, 'Concept');

INSERT INTO E_g VALUES (100, 1, 2, 'RelatesTo');

INSERT INTO E_g VALUES (101, 1, 3, 'IsA');

INSERT INTO NP_g VALUES (1, 'name', 'Alice');

INSERT INTO NP_g VALUES (2, 'name', 'Bob');

INSERT INTO NP_g VALUES (3, 'name', 'Person');

((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R2 CROSS JOIN N_g AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'RelatesTo' AND R2._1 = 'Entity' AND R4._1 = 'Entity'));

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_EntityRelations_0 CASCADE

CREATE VIEW MATCH_EntityRelations_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'RelatesTo' AND R1._1 = 'Entity' AND R2._1 = 'Entity'));

DROP VIEW IF EXISTS DMAP_EntityRelations CASCADE

CREATE VIEW DMAP_EntityRelations AS ((SELECT DISTINCT R0._0 AS _0, R0._0 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS N_EntityRelations CASCADE

CREATE VIEW N_EntityRelations AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS E_EntityRelations CASCADE

CREATE VIEW E_EntityRelations AS ((SELECT DISTINCT R0._0 AS _0, R1._1 AS _1, R2._1 AS _2, R0._3 AS _3 FROM E_g AS R0 CROSS JOIN DMAP_EntityRelations AS R1 CROSS JOIN DMAP_EntityRelations AS R2 WHERE R0._2 = R2._0 AND R0._1 = R1._0));

((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_EntityRelations AS R0 CROSS JOIN N_EntityRelations AS R2 CROSS JOIN N_EntityRelations AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'RelatesTo' AND R2._1 = 'Entity' AND R4._1 = 'Entity'));

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('Entity');

INSERT INTO N_schema VALUES ('Concept');

INSERT INTO N_schema VALUES ('Document');

INSERT INTO E_schema VALUES ('Entity', 'Concept', 'IsA');

INSERT INTO E_schema VALUES ('Entity', 'Entity', 'RelatesTo');

INSERT INTO E_schema VALUES ('Document', 'Entity', 'Mentions');

INSERT INTO N_g VALUES (1, 'Entity');

INSERT INTO NP_g VALUES (1, 'name', 'Alice');

INSERT INTO NP_g VALUES (1, 'type', 'person');

INSERT INTO NP_g VALUES (1, 'role', 'engineer');

INSERT INTO N_g VALUES (2, 'Entity');

INSERT INTO NP_g VALUES (2, 'name', 'Bob');

INSERT INTO NP_g VALUES (2, 'type', 'person');

INSERT INTO NP_g VALUES (2, 'role', 'scientist');

INSERT INTO N_g VALUES (3, 'Entity');

INSERT INTO NP_g VALUES (3, 'name', 'Python');

INSERT INTO NP_g VALUES (3, 'type', 'technology');

INSERT INTO N_g VALUES (4, 'Entity');

INSERT INTO NP_g VALUES (4, 'name', 'AI');

INSERT INTO NP_g VALUES (4, 'type', 'technology');

INSERT INTO N_g VALUES (100, 'Concept');

INSERT INTO NP_g VALUES (100, 'name', 'Person');

INSERT INTO N_g VALUES (101, 'Concept');

INSERT INTO NP_g VALUES (101, 'name', 'Technology');

INSERT INTO N_g VALUES (200, 'Document');

INSERT INTO NP_g VALUES (200, 'title', 'ResearchPaper');

INSERT INTO NP_g VALUES (200, 'year', '2024');

INSERT INTO N_g VALUES (201, 'Document');

INSERT INTO NP_g VALUES (201, 'title', 'Tutorial');

INSERT INTO NP_g VALUES (201, 'year', '2023');

INSERT INTO E_g VALUES (10, 1, 100, 'IsA');

INSERT INTO EP_g VALUES (10, 'description', 'isaPerson');

INSERT INTO E_g VALUES (11, 2, 100, 'IsA');

INSERT INTO EP_g VALUES (11, 'description', 'isaPerson');

INSERT INTO E_g VALUES (12, 3, 101, 'IsA');

INSERT INTO EP_g VALUES (12, 'description', 'isaTechnology');

INSERT INTO E_g VALUES (13, 4, 101, 'IsA');

INSERT INTO EP_g VALUES (13, 'description', 'isaTechnology');

INSERT INTO E_g VALUES (14, 1, 2, 'RelatesTo');

INSERT INTO EP_g VALUES (14, 'description', 'knowsBob');

INSERT INTO E_g VALUES (15, 1, 3, 'RelatesTo');

INSERT INTO EP_g VALUES (15, 'description', 'usesPython');

INSERT INTO E_g VALUES (16, 2, 4, 'RelatesTo');

INSERT INTO EP_g VALUES (16, 'description', 'researchesAI');

INSERT INTO E_g VALUES (17, 200, 4, 'Mentions');

INSERT INTO EP_g VALUES (17, 'description', 'mentionsAI');

INSERT INTO E_g VALUES (18, 200, 2, 'Mentions');

INSERT INTO EP_g VALUES (18, 'description', 'mentionsBob');

INSERT INTO E_g VALUES (19, 201, 3, 'Mentions');

INSERT INTO EP_g VALUES (19, 'description', 'mentionsPython');

INSERT INTO E_g VALUES (20, 201, 1, 'Mentions');

INSERT INTO EP_g VALUES (20, 'description', 'mentionsAlice');

((SELECT DISTINCT R0._0 AS _0, R0._2 AS _1, R0._1 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R2 CROSS JOIN N_g AS R4 WHERE R0._2 = R2._0 AND R0._1 = R4._0 AND R0._3 = 'IsA' AND R2._1 = 'Concept' AND R4._1 = 'Entity'));

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_PersonNetwork_0 CASCADE

CREATE VIEW MATCH_PersonNetwork_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2, R3._2 AS _3, R5._2 AS _4 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 CROSS JOIN NP_g AS R3 CROSS JOIN NP_g AS R5 WHERE R0._1 = R1._0 AND R0._1 = R3._0 AND R0._2 = R2._0 AND R0._2 = R5._0 AND R3._2 = 'person' AND R5._2 = 'person' AND R0._3 = 'RelatesTo' AND R1._1 = 'Entity' AND R2._1 = 'Entity' AND R3._1 = 'type' AND R5._1 = 'type'));

DROP VIEW IF EXISTS DMAP_PersonNetwork CASCADE

CREATE VIEW DMAP_PersonNetwork AS ((SELECT DISTINCT R0._0 AS _0, R0._0 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS N_PersonNetwork CASCADE

CREATE VIEW N_PersonNetwork AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS E_PersonNetwork CASCADE

CREATE VIEW E_PersonNetwork AS ((SELECT DISTINCT R0._0 AS _0, R1._1 AS _1, R2._1 AS _2, R0._3 AS _3 FROM E_g AS R0 CROSS JOIN DMAP_PersonNetwork AS R1 CROSS JOIN DMAP_PersonNetwork AS R2 WHERE R0._2 = R2._0 AND R0._1 = R1._0));

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_TechRelations_0 CASCADE

CREATE VIEW MATCH_TechRelations_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2, R3._2 AS _3 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 CROSS JOIN NP_g AS R3 WHERE R0._2 = R1._0 AND R0._2 = R3._0 AND R0._1 = R2._0 AND R3._2 = 'technology' AND R0._3 = 'RelatesTo' AND R1._1 = 'Entity' AND R2._1 = 'Entity' AND R3._1 = 'type'));

DROP VIEW IF EXISTS DMAP_TechRelations CASCADE

CREATE VIEW DMAP_TechRelations AS ((SELECT DISTINCT R0._0 AS _0, R0._0 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS N_TechRelations CASCADE

CREATE VIEW N_TechRelations AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS E_TechRelations CASCADE

CREATE VIEW E_TechRelations AS ((SELECT DISTINCT R0._0 AS _0, R1._1 AS _1, R2._1 AS _2, R0._3 AS _3 FROM E_g AS R0 CROSS JOIN DMAP_TechRelations AS R1 CROSS JOIN DMAP_TechRelations AS R2 WHERE R0._2 = R2._0 AND R0._1 = R1._0));

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_DocumentKnowledge_0 CASCADE

CREATE VIEW MATCH_DocumentKnowledge_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Mentions' AND R1._1 = 'Document' AND R2._1 = 'Entity'));

DROP VIEW IF EXISTS DMAP_DocumentKnowledge CASCADE

CREATE VIEW DMAP_DocumentKnowledge AS ((SELECT DISTINCT R0._0 AS _0, R0._0 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS N_DocumentKnowledge CASCADE

CREATE VIEW N_DocumentKnowledge AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS E_DocumentKnowledge CASCADE

CREATE VIEW E_DocumentKnowledge AS ((SELECT DISTINCT R0._0 AS _0, R1._1 AS _1, R2._1 AS _2, R0._3 AS _3 FROM E_g AS R0 CROSS JOIN DMAP_DocumentKnowledge AS R1 CROSS JOIN DMAP_DocumentKnowledge AS R2 WHERE R0._2 = R2._0 AND R0._1 = R1._0));

((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_PersonNetwork AS R0 CROSS JOIN N_PersonNetwork AS R2 CROSS JOIN N_PersonNetwork AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'RelatesTo' AND R2._1 = 'Entity' AND R4._1 = 'Entity'));

((SELECT DISTINCT R0._0 AS _0, R0._2 AS _1, R0._1 AS _2 FROM E_TechRelations AS R0 CROSS JOIN N_TechRelations AS R2 CROSS JOIN N_TechRelations AS R4 WHERE R0._2 = R2._0 AND R0._1 = R4._0 AND R0._3 = 'RelatesTo' AND R2._1 = 'Entity' AND R4._1 = 'Entity'));

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION GENNEWID_MAP_ExpertiseGraph_expertise(int,int)
	RETURNS int AS $$
DECLARE
	existing_id integer;
BEGIN
SELECT * INTO existing_id FROM GENNEWID_CONST('ExpertiseGraph_expertise', VARIADIC Array[$1,$2]) AS T;
RETURN existing_id;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_ExpertiseGraph_0 CASCADE

CREATE VIEW MATCH_ExpertiseGraph_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2, R3._2 AS _3, R5._2 AS _4 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 CROSS JOIN NP_g AS R3 CROSS JOIN NP_g AS R5 WHERE R0._1 = R1._0 AND R0._1 = R3._0 AND R0._2 = R2._0 AND R0._2 = R5._0 AND R3._2 = 'person' AND R5._2 = 'technology' AND R0._3 = 'RelatesTo' AND R1._1 = 'Entity' AND R2._1 = 'Entity' AND R3._1 = 'type' AND R5._1 = 'type'));

DROP VIEW IF EXISTS DMAP_ExpertiseGraph CASCADE

CREATE VIEW DMAP_ExpertiseGraph AS ((SELECT DISTINCT R0._0 AS _0, R0._0 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS N_ExpertiseGraph CASCADE

CREATE VIEW N_ExpertiseGraph AS ((SELECT DISTINCT R1._1 AS _0, 'Entity' AS _1 FROM MATCH_ExpertiseGraph_0 AS R1) UNION (SELECT DISTINCT R1._2 AS _0, 'Entity' AS _1 FROM MATCH_ExpertiseGraph_0 AS R1) UNION (SELECT DISTINCT R0._0 AS _0, R0._1 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS E_ExpertiseGraph CASCADE

CREATE VIEW E_ExpertiseGraph AS ((SELECT DISTINCT GENNEWID_CONST('ExpertiseGraph_expertise', VARIADIC Array[R1._1,R1._2]) AS _0, R1._1 AS _1, R1._2 AS _2, 'HasExpertiseIn' AS _3 FROM MATCH_ExpertiseGraph_0 AS R1) UNION (SELECT DISTINCT R0._0 AS _0, R1._1 AS _1, R2._1 AS _2, R0._3 AS _3 FROM E_g AS R0 CROSS JOIN DMAP_ExpertiseGraph AS R1 CROSS JOIN DMAP_ExpertiseGraph AS R2 WHERE R0._2 = R2._0 AND R0._1 = R1._0));

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_ExpertiseGraph AS R0 CROSS JOIN N_ExpertiseGraph AS R2 CROSS JOIN N_ExpertiseGraph AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'HasExpertiseIn' AND R2._1 = 'Entity' AND R4._1 = 'Entity'));

INSERT INTO N_schema VALUES ('Entity');

INSERT INTO N_schema VALUES ('Concept');

INSERT INTO N_schema VALUES ('Document');

INSERT INTO E_schema VALUES ('Entity', 'Concept', 'IsA');

INSERT INTO E_schema VALUES ('Entity', 'Entity', 'RelatesTo');

INSERT INTO E_schema VALUES ('Document', 'Entity', 'Mentions');

INSERT INTO N_g VALUES (1, 'Entity');

INSERT INTO NP_g VALUES (1, 'name', 'Alice');

INSERT INTO NP_g VALUES (1, 'type', 'person');

INSERT INTO NP_g VALUES (1, 'role', 'engineer');

INSERT INTO N_g VALUES (2, 'Entity');

INSERT INTO NP_g VALUES (2, 'name', 'Bob');

INSERT INTO NP_g VALUES (2, 'type', 'person');

INSERT INTO NP_g VALUES (2, 'role', 'scientist');

INSERT INTO N_g VALUES (3, 'Entity');

INSERT INTO NP_g VALUES (3, 'name', 'Python');

INSERT INTO NP_g VALUES (3, 'type', 'technology');

INSERT INTO N_g VALUES (4, 'Entity');

INSERT INTO NP_g VALUES (4, 'name', 'AI');

INSERT INTO NP_g VALUES (4, 'type', 'technology');

INSERT INTO N_g VALUES (100, 'Concept');

INSERT INTO NP_g VALUES (100, 'name', 'Person');

INSERT INTO N_g VALUES (101, 'Concept');

INSERT INTO NP_g VALUES (101, 'name', 'Technology');

INSERT INTO N_g VALUES (200, 'Document');

INSERT INTO NP_g VALUES (200, 'title', 'ResearchPaper');

INSERT INTO NP_g VALUES (200, 'year', '2024');

INSERT INTO N_g VALUES (201, 'Document');

INSERT INTO NP_g VALUES (201, 'title', 'Tutorial');

INSERT INTO NP_g VALUES (201, 'year', '2023');

INSERT INTO E_g VALUES (10, 1, 100, 'IsA');

INSERT INTO EP_g VALUES (10, 'description', 'isaPerson');

INSERT INTO E_g VALUES (11, 2, 100, 'IsA');

INSERT INTO EP_g VALUES (11, 'description', 'isaPerson');

INSERT INTO E_g VALUES (12, 3, 101, 'IsA');

INSERT INTO EP_g VALUES (12, 'description', 'isaTechnology');

INSERT INTO E_g VALUES (13, 4, 101, 'IsA');

INSERT INTO EP_g VALUES (13, 'description', 'isaTechnology');

INSERT INTO E_g VALUES (14, 1, 2, 'RelatesTo');

INSERT INTO EP_g VALUES (14, 'description', 'knowsBob');

INSERT INTO E_g VALUES (15, 1, 3, 'RelatesTo');

INSERT INTO EP_g VALUES (15, 'description', 'usesPython');

INSERT INTO E_g VALUES (16, 2, 4, 'RelatesTo');

INSERT INTO EP_g VALUES (16, 'description', 'researchesAI');

INSERT INTO E_g VALUES (17, 200, 4, 'Mentions');

INSERT INTO EP_g VALUES (17, 'description', 'mentionsAI');

INSERT INTO E_g VALUES (18, 200, 2, 'Mentions');

INSERT INTO EP_g VALUES (18, 'description', 'mentionsBob');

INSERT INTO E_g VALUES (19, 201, 3, 'Mentions');

INSERT INTO EP_g VALUES (19, 'description', 'mentionsPython');

INSERT INTO E_g VALUES (20, 201, 1, 'Mentions');

INSERT INTO EP_g VALUES (20, 'description', 'mentionsAlice');

((SELECT DISTINCT R0._0 AS _0, R0._2 AS _1, R0._1 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R2 CROSS JOIN N_g AS R4 WHERE R0._2 = R2._0 AND R0._1 = R4._0 AND R0._3 = 'IsA' AND R2._1 = 'Concept' AND R4._1 = 'Entity'));

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION GENNEWID_MAP_ExpertiseGraph_expertise(int,int)
	RETURNS int AS $$
DECLARE
	existing_id integer;
BEGIN
SELECT * INTO existing_id FROM GENNEWID_CONST('ExpertiseGraph_expertise', VARIADIC Array[$1,$2]) AS T;
RETURN existing_id;
END;
$$ LANGUAGE 'plpgsql';


DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION GENNEWID_MAP_ExpertiseGraph_expertise(int,int)
	RETURNS int AS $$
DECLARE
	existing_id integer;
BEGIN
SELECT * INTO existing_id FROM GENNEWID_CONST('ExpertiseGraph_expertise', VARIADIC Array[$1,$2]) AS T;
RETURN existing_id;
END;
$$ LANGUAGE 'plpgsql';


DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION GENNEWID_MAP_ExpertiseGraph_expertise(int,int)
	RETURNS int AS $$
DECLARE
	existing_id integer;
BEGIN
SELECT * INTO existing_id FROM GENNEWID_CONST('ExpertiseGraph_expertise', VARIADIC Array[$1,$2]) AS T;
RETURN existing_id;
END;
$$ LANGUAGE 'plpgsql';


((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_PersonNetwork AS R0 CROSS JOIN N_PersonNetwork AS R2 CROSS JOIN N_PersonNetwork AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'RelatesTo' AND R2._1 = 'Entity' AND R4._1 = 'Entity'));

((SELECT DISTINCT R0._0 AS _0, R0._2 AS _1, R0._1 AS _2 FROM E_TechRelations AS R0 CROSS JOIN N_TechRelations AS R2 CROSS JOIN N_TechRelations AS R4 WHERE R0._2 = R2._0 AND R0._1 = R4._0 AND R0._3 = 'RelatesTo' AND R2._1 = 'Entity' AND R4._1 = 'Entity'));

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION GENNEWID_MAP_ExpertiseGraph_expertise(int,int)
	RETURNS int AS $$
DECLARE
	existing_id integer;
BEGIN
SELECT * INTO existing_id FROM GENNEWID_CONST('ExpertiseGraph_expertise', VARIADIC Array[$1,$2]) AS T;
RETURN existing_id;
END;
$$ LANGUAGE 'plpgsql';


((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_ExpertiseGraph AS R0 CROSS JOIN N_ExpertiseGraph AS R2 CROSS JOIN N_ExpertiseGraph AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'HasExpertiseIn' AND R2._1 = 'Entity' AND R4._1 = 'Entity'));

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('TestNode');

INSERT INTO E_schema VALUES ('TestNode', 'TestNode', 'TestEdge');

INSERT INTO N_g VALUES (1, 'TestNode');

INSERT INTO N_g VALUES (2, 'TestNode');

INSERT INTO E_g VALUES (10, 1, 2, 'TestEdge');

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R2 CROSS JOIN N_g AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'TestEdge' AND R2._1 = 'TestNode' AND R4._1 = 'TestNode'));

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


CREATE OR REPLACE FUNCTION GENNEWID_MAP_ExpertiseGraph_expertise(int,int)
	RETURNS int AS $$
DECLARE
	existing_id integer;
BEGIN
SELECT * INTO existing_id FROM GENNEWID_CONST('ExpertiseGraph_expertise', VARIADIC Array[$1,$2]) AS T;
RETURN existing_id;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_TestView_0 CASCADE

CREATE VIEW MATCH_TestView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'TestEdge' AND R1._1 = 'TestNode' AND R2._1 = 'TestNode'));

DROP VIEW IF EXISTS DMAP_TestView CASCADE

CREATE VIEW DMAP_TestView AS ((SELECT DISTINCT R0._0 AS _0, R0._0 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS N_TestView CASCADE

CREATE VIEW N_TestView AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS E_TestView CASCADE

CREATE VIEW E_TestView AS ((SELECT DISTINCT R0._0 AS _0, R1._1 AS _1, R2._1 AS _2, R0._3 AS _3 FROM E_g AS R0 CROSS JOIN DMAP_TestView AS R1 CROSS JOIN DMAP_TestView AS R2 WHERE R0._2 = R2._0 AND R0._1 = R1._0));

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_TestView AS R0 CROSS JOIN N_TestView AS R2 CROSS JOIN N_TestView AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'TestEdge' AND R2._1 = 'TestNode' AND R4._1 = 'TestNode'));

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('TestNode');

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R2 CROSS JOIN N_g AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

INSERT INTO N_g_g VALUES (1, 'Person');

INSERT INTO N_g_g VALUES (2, 'Person');

INSERT INTO E_g_g VALUES (100, '1', '2', 'Knows');

INSERT INTO N_g VALUES (1, 'Person');

INSERT INTO N_g VALUES (2, 'Person');

INSERT INTO E_g VALUES (100, 1, 2, 'Knows');

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R2 CROSS JOIN N_g AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

DROP TABLE IF EXISTS GENNEWID_MAP CASCADE;


CREATE TABLE GENNEWID_MAP (
  NEWID SERIAL PRIMARY KEY NOT NULL,
  VIEWRULEID varchar(64) NOT NULL,
  INPUTS integer[]
);
CREATE INDEX IF NOT EXISTS newid_vrm_idx ON GENNEWID_MAP (VIEWRULEID, INPUTS);
ALTER SEQUENCE GENNEWID_MAP_NEWID_seq RESTART WITH 100000000 INCREMENT BY 1;
CREATE OR REPLACE FUNCTION GENNEWID_CONST(varchar(64), VARIADIC arr int[])
   RETURNS int AS $$
DECLARE
  inserted_id integer;
  existing_id integer;
BEGIN
  SELECT NEWID INTO existing_id FROM GENNEWID_MAP
  WHERE VIEWRULEID = $1 AND INPUTS = $2;
  IF not found THEN
    INSERT INTO GENNEWID_MAP (VIEWRULEID, INPUTS) VALUES ($1,$2) RETURNING NEWID INTO inserted_id;
    RETURN inserted_id;
  ELSE
    RETURN existing_id;
  END IF;
END;
$$ LANGUAGE 'plpgsql';


DROP VIEW IF EXISTS MATCH_PersonView_0 CASCADE

CREATE VIEW MATCH_PersonView_0 AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1, R0._2 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R1 CROSS JOIN N_g AS R2 WHERE R0._1 = R1._0 AND R0._2 = R2._0 AND R0._3 = 'Knows' AND R1._1 = 'Person' AND R2._1 = 'Person'));

DROP VIEW IF EXISTS DMAP_PersonView CASCADE

CREATE VIEW DMAP_PersonView AS ((SELECT DISTINCT R0._0 AS _0, R0._0 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS N_PersonView CASCADE

CREATE VIEW N_PersonView AS ((SELECT DISTINCT R0._0 AS _0, R0._1 AS _1 FROM N_g AS R0));

DROP VIEW IF EXISTS E_PersonView CASCADE

CREATE VIEW E_PersonView AS ((SELECT DISTINCT R0._0 AS _0, R1._1 AS _1, R2._1 AS _2, R0._3 AS _3 FROM E_g AS R0 CROSS JOIN DMAP_PersonView AS R1 CROSS JOIN DMAP_PersonView AS R2 WHERE R0._2 = R2._0 AND R0._1 = R1._0));

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_schema (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS E_schema (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EGD (_0 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_VIEW (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024), _3 VARCHAR(1024), _4 INT DEFAULT 0)

CREATE TABLE IF NOT EXISTS CATALOG_INDEX (_0 VARCHAR(1024), _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS CATALOG_SINDEX (_0 VARCHAR(1024), _1 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS N_g (_0 INT DEFAULT 0, _1 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS N_g___0 ON N_g (_0)

CREATE INDEX IF NOT EXISTS N_g___1 ON N_g (_1)

CREATE TABLE IF NOT EXISTS E_g (_0 INT DEFAULT 0, _1 INT DEFAULT 0, _2 INT DEFAULT 0, _3 VARCHAR(1024))

CREATE INDEX IF NOT EXISTS E_g___0 ON E_g (_0)

CREATE INDEX IF NOT EXISTS E_g___1 ON E_g (_1)

CREATE INDEX IF NOT EXISTS E_g___2 ON E_g (_2)

CREATE INDEX IF NOT EXISTS E_g___3 ON E_g (_3)

CREATE TABLE IF NOT EXISTS NP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

CREATE TABLE IF NOT EXISTS EP_g (_0 INT DEFAULT 0, _1 VARCHAR(1024), _2 VARCHAR(1024))

INSERT INTO N_schema VALUES ('Person');

INSERT INTO E_schema VALUES ('Person', 'Person', 'Knows');

INSERT INTO N_g VALUES (10, 'Person');

INSERT INTO N_g VALUES (20, 'Person');

INSERT INTO E_g VALUES (200, 10, 20, 'Knows');

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R2 CROSS JOIN N_g AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R2 CROSS JOIN N_g AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R2 CROSS JOIN N_g AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

((SELECT DISTINCT R0._1 AS _0, R0._2 AS _1, R0._0 AS _2 FROM E_g AS R0 CROSS JOIN N_g AS R2 CROSS JOIN N_g AS R4 WHERE R0._1 = R2._0 AND R0._2 = R4._0 AND R0._3 = 'Knows' AND R2._1 = 'Person' AND R4._1 = 'Person'));

